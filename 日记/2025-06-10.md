- [x] leetcode 进度：29 / 29
- [ ]  Android 知识点
	- [x]  《Android 开发艺术探索》 3 / 14
	- Kotlin 相关：协程（b站抛物线）、线程和进程（Android 开发艺探索章节有）


- [ ] java 知识点 && 项目再次梳理
	- [34 道 Java 精选面试题👍 | 二哥的Java进阶之路](https://javabetter.cn/interview/java-34.html#_7-arraylist-%E5%92%8C-linkedlist-%E7%9A%84%E5%8C%BA%E5%88%AB)中的知识点进度 30 / 34
	- jvm 原理解析
	- 诸葛关于 java 的视频
- [ ] 简历整理（包括数据）
- [ ] 面经数： 0 / 3



### 通过栈的方式实现的三种遍历

##### 先序遍历：
```
public void preorderTraversal(TreeNode root) {
    if (root == null) return;
    
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        System.out.print(node.val + " "); // 访问节点
        
        // 先右后左，保证左子树先被访问
        if (node.right != null) {
            stack.push(node.right);
        }
        if (node.left != null) {
            stack.push(node.left);
        }
    }
}
```
##### 中序遍历：
```
public void inorderTraversal(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode curr = root;
    
    while (curr != null || !stack.isEmpty()) {
        // 深入左子树
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        
        // 访问节点并转向右子树
        curr = stack.pop();
        System.out.print(curr.val + " ");
        curr = curr.right;
    }
}
```

##### 后序遍历(单栈法)：
1. 创建空栈，设置当前节点为根节点
2. 循环直到当前节点为空且栈为空：
		深入左子树直到叶子节点
		检查栈顶节点的右子节点
		如果右子节点存在且未被访问，转向右子树
		否则弹出栈顶节点并访问
```
public void postorderTraversalSingleStack(TreeNode root) {
    if (root == null) return;
    
    Stack<TreeNode> stack = new Stack<>();
    TreeNode curr = root;
    TreeNode prev = null; // 记录上一个访问的节点
    
    while (curr != null || !stack.isEmpty()) {
        // 深入左子树
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        
        TreeNode top = stack.peek();
        
        // 如果右子树存在且未被访问，转向右子树
        if (top.right != null && top.right != prev) {
            curr = top.right;
        } else {
            // 访问节点
            stack.pop();
            System.out.print(top.val + " ");
            prev = top; // 记录已访问
        }
    }
}
```


#### 为什么相同逻辑的代码看起来会有不同
```
// 版本A (直接比较)
if (path1.get(i) == path2.get(i)) {
    res = path1.get(i);
} else {
    continue;
}

// 版本B (使用局部变量)
int x = path1.get(i);
int y = path2.get(i);
if (x == y) {
    res = x;
} else {
    continue;
}
```
### 为什么逻辑上完全等价？

1. **比较操作相同**：
    
    - 版本A：`path1.get(i) == path2.get(i)` 比较两个Integer对象
        
    - 版本B：`x == y` 比较两个int基本类型值
        
2. **赋值操作相同**：
    
    - 版本A：`res = path1.get(i)` 赋Integer对象
        
    - 版本B：`res = x` 赋int基本类型值
        
3. **控制流相同**：
    
    - 两者都使用`continue`跳过当前迭代
        
    - 循环继续条件相同
        

### 为什么您观察到不同效果？

根本原因在于**Integer对象的缓存机制**和**自动装箱拆箱**行为：

#### Java Integer缓存机制

- Java对-128到127之间的Integer对象有缓存
    
- 范围内：`Integer a = 100; Integer b = 100;` → `a == b` 为true
    
- 范围外：`Integer a = 200; Integer b = 200;` → `a == b` 为false