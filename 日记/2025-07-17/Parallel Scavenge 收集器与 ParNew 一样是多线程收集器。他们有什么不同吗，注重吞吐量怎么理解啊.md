### **Parallel Scavenge 与 ParNew 的区别及“吞吐量优先”解析**

#### **1. 核心区别：设计目标不同**

|特性|**Parallel Scavenge**|**ParNew**|
|---|---|---|
|**设计目标**|**吞吐量优先**（最大化 CPU 利用率）|**低停顿时间**（适合交互式应用）|
|**适用场景**|后台计算、批处理任务（如数据分析、科学计算）|Web 服务、高响应需求应用（如电商系统）|
|**自适应调节**|✅ 支持（自动调整堆大小、Eden/Survivor 比例等）|❌ 不支持|
|**搭配的老年代收集器**|Parallel Old（JDK1.6+）|CMS（JDK1.7 之前）或 Serial Old（备选）|

#### **2. 吞吐量的定义与优化方式**

**吞吐量（Throughput）** 的计算公式：

吞吐量=运行用户代码时间运行用户代码时间+垃圾回收时间吞吐量=运行用户代码时间+垃圾回收时间运行用户代码时间​

- **高吞吐量**（如 99%）意味着垃圾回收占用 CPU 的时间极少，适合长时间运行的运算任务28。
    
- **优化手段**：
    
    - **减少 GC 频率**：通过增大新生代空间，让每次 GC 回收更多对象，但单次停顿时间可能变长49。
        
    - **自适应策略**（`-XX:+UseAdaptiveSizePolicy`）：自动调整参数（如 Eden/Survivor 比例），平衡吞吐量与停顿时间810。
        

#### **3. 参数对比**

|参数|**Parallel Scavenge** 的作用|**ParNew** 的类似功能|
|---|---|---|
|`-XX:MaxGCPauseMillis`|设置最大 GC 停顿时间（软目标，可能牺牲吞吐量）|❌ 无直接等效参数|
|`-XX:GCTimeRatio`|控制吞吐量（如 `19` 表示 GC 时间占比 ≤5%）|❌ 无直接等效参数|
|`-XX:ParallelGCThreads`|设置并行回收线程数（默认与 CPU 核数相关）|✅ 同样支持|

#### **4. 停顿时间 vs. 吞吐量的权衡**

- **ParNew**：通过频繁 GC（短停顿）减少单次影响，但总吞吐量可能降低37。
    
- **Parallel Scavenge**：允许更长单次停顿，但减少 GC 总次数，提升整体吞吐量29。
    

#### **5. 实际应用建议**

- **选 Parallel Scavenge**：若应用是 **CPU 密集型任务**（如离线计算、日志处理），且对短暂停顿不敏感68。
    
- **选 ParNew + CMS**：若需 **低延迟**（如在线服务），但注意 CMS 的碎片化和浮动垃圾问题35。
    

**总结**：两者虽同为多线程新生代收集器，但 **Parallel Scavenge 通过牺牲部分停顿时间换取更高吞吐量**，适合后台任务；而 **ParNew 更关注响应速度**，适合交互式系统