在 Android 开发中，**优先使用静态内部类（Static Nested Class）而非非静态内部类（Inner Class）**，是避免内存泄漏的重要实践。以下是详细解析和示例：

---

### **1. 为什么非静态内部类可能导致内存泄漏？**

#### **问题根源**

- **非静态内部类隐式持有外部类引用**：  
    非静态内部类会自动持有外部类的实例（`OuterClass.this`）。如果该内部类的生命周期长于外部类（例如异步任务、Handler、线程等），会导致外部类无法被回收。

#### **典型场景**
```java
public class MainActivity extends Activity {
    private TextView mTextView;

    // 非静态内部类（危险！）
    private class MyLeakyHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            mTextView.setText("Done"); // 隐式持有 MainActivity.this
        }
    }
}
```

- **风险**：若 `Handler` 未完成时 Activity 被销毁（如屏幕旋转），Activity 实例会因被 `Handler` 持有而泄漏。
    

---

### **2. 解决方案：静态内部类 + 弱引用**

#### **改进代码**
```java
public class MainActivity extends Activity {
    private TextView mTextView;

    // 静态内部类（安全）
    private static class MySafeHandler extends Handler {
        // 弱引用避免内存泄漏
        private final WeakReference<MainActivity> mActivityRef;

        MySafeHandler(MainActivity activity) {
            mActivityRef = new WeakReference<>(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            MainActivity activity = mActivityRef.get();
            if (activity != null && !activity.isFinishing()) {
                activity.mTextView.setText("Done");
            }
        }
    }
}
```

#### **关键点**

|改进措施|作用|
|---|---|
|**静态内部类**|切断与外部类的隐式关联，避免强引用。|
|**弱引用（WeakReference）**|允许外部类在不需要时被 GC 回收，通过 `get()` 检查有效性。|
|**生命周期检查**|调用前验证 Activity 是否未被销毁（`isFinishing()`）。|

---